---
title: '`voice` vignette - The Python part'
subtitle: 'version `r packageVersion("voice")`'
author: 'Filipe J. Zabala'
date: "`r format(Sys.time(), '%Y-%m-%d %H:%M:%S')`"
output:
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{`voice` vignette}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
ini0 <- Sys.time()
```

## 0. Installation
https://github.com/filipezabala/voice

## 1. Extract features
### Load packages
```{r, message=FALSE, warning=FALSE}
# packs
library(voice)
library(tidyverse)
library(music)
library(gm)
```
### Setting directories and removing old ones
```{r}
dirs <- c('vaDir', 'wavDir', 'mp3Dir', 'musicxmlDir')
vaDir <- '~/Downloads/voiceAudios'
for(i in 1:length(dirs)){
  if(i>1){ assign(dirs[i], paste0(get(dirs[1]), '/', dirs[i])) }
  ifelse(!dir.exists(get(dirs[i])), dir.create(get(dirs[i])), 'Directory exists!')
}
cmd <- paste0('rm ', wavDir, '/*.*; ', 'rm ', mp3Dir, '/*.*')
system(cmd)
```


<!-- #### >>> To do #10 [SOLVED @ VERSION 0.0.0.9044 2021-09-12] -->
<!-- Automatize and test `autoDir` argument @ splitw.R.  <<< -->

<!-- #### >>> To do #20 [SOLVED @ VERSION 0.0.0.9044 2021-09-12] -->
<!-- Parameters fromWav, fromRttm admits either file or directory @ splitw.R. <<< -->

### Get audio
```{r}
url0 <- 'https://github.com/filipezabala/voiceAudios/blob/main/mp3/doremi.mp3?raw=true'
download.file(url0, paste0(mp3Dir, '/doremi.mp3'), mode = 'wb')
embedr::embed_audio(url0, attribute = c("controls"))
```

<!-- #### >>> To do #30 [SOLVED in 2021-11-07] -->
<!-- Insert a button to play audio files. <<< -->

<!-- #### >>> To do #40 -->
<!-- At `url0 <- 'https://github.com/filipezabala/voiceAudios/raw/main/bebezinho_2.005.wav'`, find out why the downloaded file is called `wav_bebezinho_2.005.wav`. <<< -->

### Convert mp3 to wav mono
```{r}
cmd <- 'cd ~/Downloads/voiceAudios/mp3Dir;
for i in *.[Mm][Pp]3; do ffmpeg -i "$i" -ac 1 "../wavDir/${i%.*}.wav"; done'
system(cmd)
```

### Extract features
```{r}
ef <- voice::extract_features(wavDir, features = c('f0','gain'),
                              round.to = 6, windowShift = 5)
ef
```
<!-- #### >>> To do #50 -->
<!-- Automatize and test `stereo2mono`. <<< -->

<!-- #### >>> To do #60 -->
<!-- Test different windowShift values.  <<< -->


## 2. Smooth
<!-- #### >>> To do #70 [SOLVED @ VERSION 0.0.0.9042 2021-09-12] -->
<!-- Write the function `smooth_df(x,k)`. <<< -->

```{r, warning=FALSE, message=FALSE}
odd <- seq(1,11,2)
ef_sm <- vector('list', length(odd))
names(ef_sm) <- paste0('k=', odd)
for(i in 1:length(ef_sm)){
  ef_sm[[i]] <- voice::smooth_df(ef, id = 3, k = i)
}
sapply(ef_sm, dim)
```

### Plot F0 smoothing
```{r, fig.height=6, fig.width=8}
par(mfrow = c(2,3))
for(i in 1:length(ef_sm)){
  plot(ef_sm[[i]]$F0, main = paste0('k = ', odd[i]))
}
```


<!-- ### Pool -->
<!-- ```{r} -->
<!-- (ef01 <- voice::conv_df(ef, .01)) # 1% -->
<!-- ``` -->
<!-- #### >>> To do -->
<!-- 1. Eliminate this step, assigning notes and durations after smooth with moving average.   -->
<!-- 2. Apply voice::duration over the smoothed data.   -->

## 3. Assign notes
Assign notes to F0.
```{r}
for(i in 1:length(ef_sm)){
  ef_sm[[i]]$F0_spn <- voice::notes(ef_sm[[i]]$F0)
}
lapply(ef_sm, dim)
```

<!-- #### >>> To do #80 [WORK IN PROGRESS] -->
<!-- Write plot_note function to show both frequency and notes in spn, midi and black formats. <<< -->

<!-- #### >>> To do #90 -->
<!-- Write a function to, given a frequency in Hz, convert in any SPN. <<< -->

<!-- #### >>> To do #100 -->
<!-- Implement and study major/minor chords identifier (consider `tabr` functions). <<< -->

<!-- #### >>> To do #110 -->
<!-- Study sequences (scales and arpeggios). <<< -->


## 4. Duration
```{r}
dur_spn <- vector('list', length(ef_sm)); names(dur_spn) <- paste0('k=', odd)
for(i in 1:length(ef_sm)){
  dur_spn[[i]] <- voice::duration(ef_sm[[i]]$F0_spn) 
}
dur_spn[[1]]
```

<!-- ## 5. Distance -->
<!-- Distance in semitones -->
<!-- ```{r} -->
<!-- nd <- vector('list', length(ef_sm)) -->
<!-- for(i in 1:length(ef_sm)){ -->
<!--   nd[[i]] <- music::noteDistance(as.character(dur_spn[[i]]$note)) -->
<!--   print(summary(nd[[i]])) -->
<!-- } -->
<!-- nd[[1]] -->
<!-- ``` -->

<!-- #### >>> To do #120 -->
<!-- Extract and test microtones. (Giuliano's idea.) <<< -->

<!-- ### Play -->
<!-- ```{r} -->
<!-- music::playNote(note = as.character(dur.spn$note), duration = dur.spn$dur_line) -->
<!-- ``` -->
<!-- #### >>> To do -->
<!-- 1. Check version to play different durations.   -->

<!-- To do:   -->
<!-- 1. Solve in Linux:   -->

<!-- ```{r} -->
<!-- # ALSA lib pcm_dmix.c:1089:(snd_pcm_dmix_open) unable to open slave -->
<!-- # ALSA lib pcm.c:2642:(snd_pcm_open_noupdate) Unknown PCM cards.pcm.rear -->
<!-- # ALSA lib pcm.c:2642:(snd_pcm_open_noupdate) Unknown PCM cards.pcm.center_lfe -->
<!-- # ALSA lib pcm.c:2642:(snd_pcm_open_noupdate) Unknown PCM cards.pcm.side -->
<!-- # ALSA lib pcm_route.c:869:(find_matching_chmap) Found no matching channel map -->
<!-- # ALSA lib pcm_oss.c:377:(_snd_pcm_oss_open) Unknown field port -->
<!-- # ALSA lib pcm_oss.c:377:(_snd_pcm_oss_open) Unknown field port -->
<!-- # ALSA lib pulse.c:242:(pulse_connect) PulseAudio: Unable to connect: Connection refused -->
<!-- #  -->
<!-- # ALSA lib pulse.c:242:(pulse_connect) PulseAudio: Unable to connect: Connection refused -->
<!-- #  -->
<!-- # ALSA lib pcm_usb_stream.c:486:(_snd_pcm_usb_stream_open) Invalid type for card -->
<!-- # ALSA lib pcm_usb_stream.c:486:(_snd_pcm_usb_stream_open) Invalid type for card -->
<!-- # ALSA lib pcm_dmix.c:1089:(snd_pcm_dmix_open) unable to open slave -->
<!-- # ALSA lib pcm_dmix.c:1089:(snd_pcm_dmix_open) unable to open slave -->
<!-- ``` -->

## 5. Music sheet
### Compress to 1%
```{r}
# compress
ef_01 <- voice::conv_df(ef, 0.01, id = 3)
# assign notes
ef_01$F0_spn <- voice::notes(ef_01$F0, measure = 'spn')
# duration
nd_01 <- voice::duration(ef_01$F0_spn)
# still manual!!
li <- list('D#3','F3','C#4','A#3')
length(li)
# gm tool
m01 <- gm::Music()
m01 <- m01 +
  # add a 4/4 time signature
  gm::Meter(4, 4) +
  # MANUALLY adding notes
  gm::Line(pitches = li,
           durations = list(1,1,1,1)) +
  # tempo
  Tempo(170)
m01
show(m01, to = c('score', 'audio'))
```

### Smooth using window k=21
```{r}
# smooth
ef_sm_21 <- voice::smooth_df(ef, k = 21, id = 3)
# assign notes
ef_sm_21$F0_spn <- voice::notes(ef_sm_21$F0, measure = 'spn')
# duration
nd_21 <- voice::duration(ef_sm_21$F0_spn)
# still manual!!
li <- list('D3','C#3','C3',NA,'C#3',NA,'B3','C4','C#4','C4','B3','A#3','A3','A#3',NA)
length(li)
# gm tool
m21 <- gm::Music()
m21 <- m21 +
  # add a 4/4 time signature
  gm::Meter(4, 4) +
  # MANUALLY adding notes
  gm::Line(pitches = li,
           durations = list(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1)) +
  # tempo
  Tempo(999)
m21
show(m21, to = c('score', 'audio'))
```

#### >>> To do #130
Automate `pitches` and `durations` at `gm::Line` to capture spn/midi from `duration` data frame. <<<


### Export musicxml file
```{r}
gm::export(m01, musicxmlDir, 'bebezinho_01', 'musicxml')
gm::export(m21, musicxmlDir, 'bebezinho_21', 'musicxml')
```


## 7. Cut audios
### Get audios
```{r}
# font url
url0 <- 'https://github.com/filipezabala/voiceAudios/raw/main/mp3/'

# mp3 files
mp3Files <- c('anthem0.mp3', 'anthem1.mp3', 'anthem2.mp3',
              'game0.mp3', 'game1.mp3', 'game2.mp3',
              'phantom0.mp3', 'phantom1.mp3',  'phantom2.mp3',
              'romeo0.mp3', 'romeo1.mp3', 'romeo2.mp3',
              'sherlock0.mp3', 'sherlock1.mp3', 'sherlock2.mp3',
              'war0.mp3', 'war1.mp3', 'war2.mp3')

# downloading just the first mp3 file (remove [1] to download all)
for(i in mp3Files[1]){
  system(paste0('wget -r -np -k ', url0, i, ' -P ~/Downloads/voiceAudios/mp3Dir'))
}

# tidying up files and directories
system('cp ~/Downloads/voiceAudios/mp3Dir/github.com/filipezabala/voiceAudios/raw/main/mp3/*.* ~/Downloads/voiceAudios/mp3Dir')
system('rm -rf ~/Downloads/voiceAudios/mp3Dir/github.com/')
```

### Remove old files
```{r}
cmd <- paste0('rm ', wavDir, '/*.*')
system(cmd)
```

### Convert mp3 to wav
```{r}
cmd <- 'cd ~/Downloads/voiceAudios/mp3Dir;
for i in *.[Mm][Pp]3; do ffmpeg -i "$i" "../wavDir/${i%.*}.wav"; done'
system(cmd)
```

<!-- #### >>> To do #140 -->
<!-- Automatize and test mp32wav. <<< -->

<!-- #### >>> To do #150 -->
<!-- Test the hypotheses   -->
<!-- H1: multiple mp32wav2mp32wav... conversions reduce the audio quality.    -->
<!-- H2: What is the impact in the decision using    -->
<!--  i. original wav    -->
<!--  ii. original mp3 (that must be converted to wav)     -->
<!--  iii. H1, if H1 is consistent <<< -->


### Poetry
The best words in their best order. Takes around the audio time at 8CPU and the double of the audio time at 4CPU.
```{r}
# voice::poetry(wavDir)
```
![](rttm.png)


<!-- #### >>> To do #160 [WORK IN PROGRESS] -->
<!-- Automate speaker recognition (who speaks when?) @ poetry.R. <<< -->

### Split wave
```{r}
# split wave
# ini <- Sys.time()
# voice::splitw(wavDir, fromRttm = rttmDir, to = splitDir)
# Sys.time()-ini
```
![](split.png)

<!-- #### >>> To do #170 [SOLVED @ VERSION 0.0.0.35 2021-08-16] -->
<!-- Automate argument `compact.to` at `voice::conv_df`. <<< -->

<!-- #### >>> To do #180 [TESTED: NOT OK WITH GAIN] -->
<!-- No gain testing weighting F0 considering GAIN and other features at `voice::conv_df`.   -->
<!-- [TEST1] No gain testing weighting F0 considering GAIN. <<< -->

<!-- #### >>> To do #190 -->
<!-- Test ZCR to infer BPM. <<< -->

<!-- #### >>> To do #200 -->
<!-- Embed `gm::show` function at MacOS. Must solve: -->
<!--   - Error in magick_image_write(image, format, quality, depth, density, comment,  :  -->
<!--   rsession: NegativeOrZeroImageSize `' @ error/image.c/CloneImage/794 <<< -->

<!-- #### >>> To do #210 -->
<!-- Find the 'best' set of variables in different contexts. <<< -->

<!-- #### >>> To do #220 [SOLVED @ VERSION 0.0.0.9041 2021-09-10] -->
<!-- Standardize `silence.gap` argument at `voice::splitw` considering NIST (National Institute of Standards and Technology) documentation. <<< -->

<!-- ## Glossary -->
<!-- . [WORK IN PROGRESS] As it says, support is welcome.      -->
<!-- . [SOLVED @ VERSION major.minor.subminor '%Y-%m-%d'].   -->
<!-- . [TESTED] During the tests no gain were obtained.    -->


```{r}
Sys.time()-ini0
```

