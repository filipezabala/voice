% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/conv_mc.R
\name{conv_mc}
\alias{conv_mc}
\title{Convolute vectors using multicore.}
\usage{
conv_mc(
  y,
  compact.to,
  drop.zeros = F,
  to.data.frame = F,
  round.off = NULL,
  mc.cores = parallel::detectCores()
)
}
\arguments{
\item{\code{y}}{A numeric vector, matrix or data frame.}

\item{\code{compact.to}}{Percentage of remaining points after compression. If equals to 1 and keep.zeros = T, the original vector is presented.}

\item{\code{drop.zeros}}{Logical. Drop repeated zeros? Default: \code{'FALSE'}.}

\item{\code{to.data.frame}}{Logical. Convert to data frame? Default: \code{'FALSE'}.}

\item{\code{round.off}}{Number of decimal places of the convoluted vector. Default: \code{'NULL'}.}

\item{\code{mc.cores}}{The number of cores to mclapply. Default: \code{'parallel::detectCores()'}.}
}
\value{
A list of x and y convoluted values with length near to \code{compact.to*length(y)}.
}
\description{
Convolute vectors using multicore.
}
\examples{
library(voice)
# Same result of conv() function if x is a vector
conv(1:100, compact.to = 0.1, drop.zeros = T, to.data.frame = F)
conv_mc(1:100, compact.to = 0.1, drop.zeros = T, to.data.frame = F)

conv(1:100, compact.to = 0.1, drop.zeros = T, to.data.frame = T)
conv_mc(1:100, compact.to = 0.1, drop.zeros = T, to.data.frame = T)

dat.num <- dat \%>\%
select(f0:mhs1)
nrow(dat.num)
cm1 <- conv_mc(dat.num, compact.to = 0.1, drop.zeros = T, to.data.frame = F)
names(cm1)
lapply(cm1$f0, length)
}
\seealso{
\code{rm0}, \code{conv}, \code{conv_df}
}
